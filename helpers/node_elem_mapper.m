function [ e2n, n2e ] = node_elem_mapper( mdl )
%NODE_ELEM_MAPPER Mapping function used to convert element data to node
%data and reverse
%   Outputs two sparse matrices (assumes we have enough memory to store
%   sparse matrices): one for mapping from element to node and one togo
%   back to the element data
%	Why 2 matrices: An element is always connected to 3 or 4 nodes, but a
%	node can be connected to any number of elements. The method proposed by
%	EIDORS function 'nodal_solve' does not consider this and therefore does
%	some crap at the boundary (and probably with models generated by
%	Netgen)
%	Initial idea from EIDORS function 'nodal_solve>elem2node'
%
%	Input: Forward or inverse model
%	Output:
%		e2n: Matrix to switch from element to node
%		n2e: To switch from node to element
%
%	(C) 2015/09/07 Sebastien Martin

if ischar(mdl) && strcmp(mdl,'UNIT_TEST'); do_unit_test; return; end

if isfield(mdl,'fwd_model'); mdl = mdl.fwd_model; end
elems = mdl.elems;
is2D = size(mdl.nodes,2)==2;

e2n_cache = eidors_obj('get-cache',elems,'e2n_map');
if isempty(e2n_cache)
    [e2n, n2e] = get_node_elem_map(elems, is2D);
    e2n_cache.e2n = e2n; e2n_cache.n2e = n2e;
    eidors_obj('set-cache',elems,'e2n_map',e2n_cache);
else
    e2n = e2n_cache.e2n;
    n2e = e2n_cache.n2e;
end

end

function [e2n, n2e] = get_node_elem_map(elems, is2D)

if is2D
    [Ne,d] = size(elems);
    elemo = (1:Ne)'*ones(1,d);
    n2e = sparse(elemo,elems,1/d);
    e2n = n2e;
    Nn = size(e2n,2);
    
    n_connected = arrayfun(@(x) sum(elems(:)==x), 1:1:Nn);
    for k=1:1:Nn
        e2n( e2n(:,k)~=0, k) = 1/n_connected(k);
    end
    e2n = e2n';
else
    e2n = compute_matrix_3D(elems);
    n2e = e2n';
    n2e(n2e~=0) = 1/size(elems,2);
end

end

% Function inspired from compute_vertex_face_ring and capable to handle 3D
% models
% http://www.mathworks.com/matlabcentral/fileexchange/5355-toolbox-graph
function e2n = compute_matrix_3D(elems)
[nfaces, nDims] = size(elems);
nverts = max(elems(:));
ring{nverts} = [];
for i=1:nfaces
    for k=1:nDims
        ring{elems(i,k)}(end+1) = i;
    end
end
len_ring = cellfun(@(x) length(x), ring);
sz_mat = sum( len_ring );
e2n = spalloc( length(ring), size(elems,1), sz_mat);
for k = 1:1:length(ring)
    c_map = ring{k};
    e2n(k, c_map) = 1/len_ring(k);
end
end

function do_unit_test
mdl = mk_common_model('c3cr'); %mk_common_model('c2C');
img = mk_image(mdl, [ones(15000,1); -ones(19560,1)]); %mk_image(mdl, [ones(76,1); -ones(500,1)]);
[e2n, n2e] = node_elem_mapper(mdl);

figure; subtightplot(2,3,1);
show_fem(img,1); title('Initial image');

img.node_data = e2n*img.elem_data;
img = rmfield(img,'elem_data');
subtightplot(2,3,2);
show_fem(img,1); title('Node data');

img.elem_data = n2e*img.node_data;
img = rmfield(img,'node_data');
subtightplot(2,3,3);
show_fem(img,1); title('Back to elem data');

img.node_data = e2n*img.elem_data;
img = rmfield(img,'elem_data');
subtightplot(2,3,5);
show_fem(img,1); title('Node data (2^{nd} conversion)');

img.elem_data = n2e*img.node_data;
img = rmfield(img,'node_data');
subtightplot(2,3,6);
show_fem(img,1); title('Back to elem data (2nd time)');
end
